# arts 

## A --  [Jewels and Stones](https://leetcode.com/problems/jewels-and-stones/description/)

发现 LeetCode 里面能够无脑解的题目很难找到了，也可能是我没仔细找。不过按照这个进度，下个星期做的题目应该是可以稍微“质量”些。

这道题目很简单，刚开始的想法是将 Stones 存为一个 Map<String, Integer>(), 这样每个 stone 都对应着自己的数量，再遍历 Jewels ，如果存在则累加，解法如下：

```java
public class JewelsAndStones771 {

  public int numJewelsInStones(String J, String S) {
    String[] jewelsArray = J.split("");
    String[] stoneArray = S.split("");
    Map<String, Integer> stoneCountMap = new HashMap<>();
    for (String stone : stoneArray) {
      Integer count = stoneCountMap.get(stone);
      stoneCountMap.put(stone, count == null ? 1 : ++count);
    }
    int result = 0;
    for (String jewels : jewelsArray) {
      Integer num = stoneCountMap.get(jewels);
      if (num != null) {
        result += num;
      }
    }
    return result;
  }
}
```

AC 之后，感觉做复杂了，应该是 Jewels 存在 HashSet 里面，这样再遍历 Stones，效果会好点：

```java
public class JewelsAndStones771 {

  public int numJewelsInStones(String J, String S) {
    int result = 0;
    HashSet<String> jewelsSet = new HashSet<String>();
    for (String jewels : J.split("")) {
      jewelsSet.add(jewels);
    }
    for (String stone : S.split("")) {
      if (jewelsSet.contains(stone)) {
        result++;
      }
    }
    return result;
  }
}
```



## R -- [CQRS](https://martinfowler.com/bliki/CQRS.html)

CQRS 全称是 Command Query Responsibility Segregation，可以译作命令、查询的责任分离模式。传统的 MVC 模式中，M 负责了数据库的 CRUD 操作，CQRS 模式将数据库的读取和执行分成了两个部分：Query Model 用来查询，Command Model 负责数据库的更新操作。这篇文章介绍了 CQRS，并且讲述了它的适用和不适用的场景。

## T -- About Tip

....

## S -- About Sharing

....